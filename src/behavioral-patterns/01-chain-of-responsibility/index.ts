/**
 * 职责链（Chain of Responsibility）
 * 定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
 *      将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。
 * 结构：
 *     -- Handler（抽象处理者）:它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处
 *        理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此
 *        在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。
 *        通过该引用，处理者可以连成一条链。
 *     -- ConcreteHandler（具体处理者）:它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现
 *        了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，
 *        如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，
 *        以便请求的转发。
 * 适用场景：
 *     -- 有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定，客户端只需要把请求提交到链上即可；
 *     -- 想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；
 *     -- 可处理一个请求的对象集合应被动态指定;
 * 优点：
 *     -- 降低耦合度。链中的对象不需知道链的结构；
 *     -- 增强了职责链组织的灵活性。可以在运行时动态改变职责链；
 * 缺点：
 *     -- 不保证被接受。一个请求可能得不到处理；
 *     -- 如果建链不当，可能会造成循环调用，将导致系统陷入死循环；
 * 相关模式：
 *     -- 职责链常常与Composite（组合模式）一起使用。一个对象的父对象可以作为他的后继者。
 */
abstract class Handler {
    protected next: Handler;

    setNext(handler: Handler) {
        this.next = handler;
    }

    abstract handle(): void;
}

class concreteHandler extends Handler {
    handle(): void {
        // if sth true do sth
        // else this.next.handle()
    }
}
