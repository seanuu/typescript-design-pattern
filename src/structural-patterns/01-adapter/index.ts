/**
 * 适配器（Adapter）
 * 定义：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
 * 结构：
 *     -- Target：目标抽象类，目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。
 *     -- Adapter：适配器类，适配器可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配
 *     -- Adaptee：适配者类
 * 适用场景：
 *     -- 你想使用一个已经存在的类，而他的接口不符合你的需求；
 *     -- 你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配他们的接口。对象适配器可以适配他的父类接口；
 * 优点：
 *     -- 将目标类和被适配类解耦，通过引入一个适配器类来重用现有的被适配类，而无须修改原有代码；
 *     -- 增加了类的透明性和复用性，将具体的实现封装在被适配类中，对于客户端类来说是透明的，而且提高了被适配类的复用性；
 *     -- 类适配器：由于适配器类是被适配类的子类，因此可以在适配器类中置换一些被适配类的方法，使得适配器的灵活性更强；
 *     -- 对象适配器：一个对象适配器可以把多个不同的被适配类适配到同一个目标，也就是说，同一个适配器可以把被适配类和它的子类都适配到目标接口；
 * 缺点：
 *     -- 类适配器：单继承机制使得同时只能适配一个被适配类；
 *     -- 对象适配器：与类适配器模式相比，要想置换被适配类的方法就不容易；
 * 相关模式：
 *     -- 桥接（Bridge）模式的结构与对象适配器类似，但桥接模式的出发点不同：桥接目的是将接口部分和实现部分分离，
 *        从而使他们可以较为容易也相对独立的加以改变。而适配器则意味着改变一个已有对象的接口。
 *     -- 代理（Proxy）模式在不改变他的接口的条件下，为另一个对象定义了一个代理。
 *     -- 装饰器（Decorator）模式增强了其他对象的功能而同时又不改变他的接口。因此装饰器对应用程序的透明性比适配器要好。
 *        装饰器支持递归组合，而纯粹使用适配器是不可能实现这一点的。
 */
interface Target {
    request(): void;
}

class Adaptee {
    specificRequest(): void {
        console.log('Adaptee specificRequest');
    }
}

class Adapter implements Target{
    private adaptee: Adaptee = new Adaptee();

    request(): void {
        this.adaptee.specificRequest();
    }
}
